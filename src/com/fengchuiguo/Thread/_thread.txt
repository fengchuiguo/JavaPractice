Java提供了两种创建线程方法：
通过实现Runable接口；
通过继承Thread类本身。

----------
JAVA多线程实现方式
JAVA多线程实现方式主要有三种：继承Thread类、实现Runnable接口、使用ExecutorService、Callable、Future实现有返回结果的多线程。
其中前两种方式线程执行完后都没有返回值，只有最后一种是带返回值的。

继承Thread类的方法尽管被列为一种多线程实现方式，但Thread本质上也是实现了Runnable接口的一个实例，它代表一个线程的实例，
并且，启动线程的唯一方法就是通过Thread类的start()实例方法。start()方法是一个native方法，它将启动一个新线程，并执行run()方法。

ExecutorService、Callable、Future这个对象实际上都是属于Executor框架中的功能类。


----------
关于锁和同步，有一下几个要点：

1）、只能同步方法，而不能同步变量和类；
2）、每个对象只有一个锁；当提到同步时，应该清楚在什么上同步？也就是说，在哪个对象上同步？
3）、不必同步类中所有的方法，类可以同时拥有同步和非同步方法。
4）、如果两个线程要执行一个类中的synchronized方法，并且两个线程使用相同的实例来调用方法，那么一次只能有一个线程能够执行方法，另一个需要等待，直到锁被释放。
    也就是说：如果一个线程在对象上获得一个锁，就没有任何其他线程可以进入（该对象的）类中的任何一个同步方法。
5）、如果线程拥有同步和非同步方法，则非同步方法可以被多个线程自由访问而不受锁的限制。
6）、线程睡眠时，它所持的任何锁都不会释放。
7）、线程可以获得多个锁。比如，在一个对象的同步方法里面调用另外一个对象的同步方法，则获取了两个对象的同步锁。
8）、同步损害并发性，应该尽可能缩小同步范围。同步不但可以同步整个方法，还可以同步方法中一部分代码块。
9）、在使用同步代码块时候，应该指定在哪个对象上同步，也就是说要获取哪个对象的锁。


----------
静态方法同步

要同步静态方法，需要一个用于整个类对象的锁，这个对象是就是这个类（XXX.class)。

例如：

public static synchronized int setName(String name){
      Xxx.name = name;
}

等价于
public static int setName(String name){
      synchronized(Xxx.class){
            Xxx.name = name;
      }
}


----------
当考虑阻塞时，一定要注意哪个对象正被用于锁定：

1、调用同一个对象中非静态同步方法的线程将彼此阻塞。如果是不同对象，则每个线程有自己的对象的锁，线程间彼此互不干预。
2、调用同一个类中的静态同步方法的线程将彼此阻塞，它们都是锁定在相同的Class对象上。
3、静态同步方法和非静态同步方法将永远不会彼此阻塞，因为静态方法锁定在Class对象上，非静态方法锁定在该类的对象上。
4、对于同步代码块，要看清楚什么对象已经用于锁定（synchronized后面括号的内容）。在同一个对象上进行同步的线程将彼此阻塞，
在不同对象上锁定的线程将永远不会彼此阻塞。


----------
何时需要同步
在多个线程同时访问互斥（可交换）数据时，应该同步以保护数据，确保两个线程不会同时修改更改它。


----------
死锁。当两个线程被阻塞，每个线程在等待另一个线程时就发生死锁。


----------
线程交互
void notify()
          唤醒在此对象监视器上等待的单个线程。
 void notifyAll()
          唤醒在此对象监视器上等待的所有线程。
 void wait()
          导致当前的线程等待，直到其他线程调用此对象的 notify()方法或 notifyAll()方法。

wait()、notify()、notifyAll()都是Object的实例方法。与每个对象具有锁一样，每个对象可以有一个线程列表，他们等待来自该信号（通知）。
线程通过执行对象上的wait()方法获得这个等待列表。从那时候起，它不再执行任何其他指令，直到调用对象的notify()方法为止。
如果多个线程在同一个对象上等待，则将只选择一个线程（不保证以何种顺序）继续执行。如果没有线程等待，则不采取任何特殊操作。

当在对象上调用wait()方法时，执行该代码的线程立即放弃它在对象上的锁。
然而调用notify()时，并不意味着这时线程会放弃其锁。
如果线程仍然在完成同步代码，则线程在移出之前不会放弃锁。因此，只要调用notify()并不意味着这时该锁变得可用。


----------
Java线程调度是Java多线程的核心，只有良好的调度，才能充分发挥系统的性能，提高程序的执行效率。

这里要明确的一点，不管程序员怎么编写调度，只能最大限度的影响线程执行的次序，而不能做到精准控制。

线程休眠的目的是使线程让出CPU的最简单的做法之一，线程休眠时候，会将CPU资源交给其他线程，以便能轮换执行，
当休眠一定时间后，线程会苏醒，进入准备状态等待执行。

线程休眠的方法是Thread.sleep(long millis)和Thread.sleep(long millis, int nanos)，均为静态方法，
那调用sleep休眠的哪个线程呢？简单说，哪个线程调用sleep，就休眠哪个线程。

与线程休眠类似，线程的优先级仍然无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。

线程的优先级用1-10之间的整数表示，数值越大优先级越高，默认的优先级为5。
setPriority()

在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。


-----------
线程的让步含义就是使当前运行着线程让出CPU资源，但是然给谁不知道，仅仅是让出，线程状态回到可运行状态。

线程的让步使用Thread.yield()方法，yield()为静态方法，功能是暂停当前正在执行的线程对象，
该线程状态回到可运行状态。但是他有可能也会被再次调用的。


----------
线程的合并的含义就是将几个并行线程的线程合并为一个单线程执行，
应用场景是当一个线程必须等待另一个线程执行完毕才能执行时可以使用join方法。

join为非静态方法，定义如下：
void join()
    等待该线程终止。
void join(long millis)
    等待该线程终止的时间最长为 millis毫秒。
void join(long millis,int nanos)
    等待该线程终止的时间最长为 millis毫秒 + nanos 纳秒。


----------
守护线程与普通线程写法上基本么啥区别，调用线程对象的方法setDaemon(true)，则可以将其设置为守护线程。

守护线程使用的情况较少，但并非无用，举例来说，JVM的垃圾回收、内存管理等线程都是守护线程。
还有就是在做数据库应用时候，使用的数据库连接池，连接池本身也包含着很多后台线程，监控连接个数、超时时间、状态等等。

JRE判断程序是否执行结束的标准是所有的前台执线程行完毕了，而不管后台线程的状态，因此，在使用后台县城时候一定要注意这个问题。


----------
在使用synchronized关键字时候，应该尽可能避免在synchronized方法或synchronized块中使用sleep或者yield方法，
因为synchronized程序块占有着对象锁，你休息那么其他的线程只能一边等着你醒来执行完了才能执行。不但严重影响效率，也不合逻辑。
同样，在同步程序块内调用yeild方法让出CPU资源也没有意义，因为你占用着锁，其他互斥线程还是无法访问同步程序块。
当然与同步程序块无关的线程可以获得更多的执行时间。


----------
线程发生死锁可能性很小，即使看似可能发生死锁的代码，在运行时发生死锁的可能性也是小之又小。
发生死锁的原因一般是两个对象的锁相互等待造成的。


----------
Java™语言包含两种内在的同步机制：同步块（或方法）和 volatile变量。
这两种机制的提出都是为了实现代码线程的安全性。其中 Volatile变量的同步性较差（但有时它更简单并且开销更低），而且其使用也更容易出错。
volatile可以用在任何变量前面，但不能用于final变量前面，因为final型的变量是禁止修改的。也不存在线程安全的问题。


----------
线程池的基本思想还是一种对象池的思想，开辟一块内存空间，里面存放了众多（未死亡）的线程，池中线程执行调度由池管理器来处理。
当有线程任务时，从池中取一个，执行完成后线程对象归池，这样可以避免反复创建线程对象所带来的性能开销，节省了系统的资源。
java.util.concurrent.Executors类的API，这个类提供大量创建连接池的静态方法


----------
锁对象，利用锁可以方便的实现资源的封锁，用来控制对竞争资源并发访问的控制，
这些内容主要集中在java.util.concurrent.locks包下面，里面有三个重要的接口Condition、Lock、ReadWriteLock。

Condition
Condition将Object监视器方法（wait、notify和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意Lock实现组合使用，
为每个对象提供多个等待 set（wait-set）。

Lock
Lock实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。

ReadWriteLock
ReadWriteLock维护了一对相关的锁定，一个用于只读操作，另一个用于写入操作。

在获取了锁对象后，用完后应该尽快释放锁，以便别的等待该锁的线程有机会去执行。


----------
Java的信号量实际上是一个功能完毕的计数器，对控制一定资源的消费与回收有着很重要的意义，
信号量常常用于多线程的代码中，并能监控有多少数目的线程等待获取资源，并且通过信号量可以得知可用资源的数目等等，
这里总是在强调“数目”二字，但不能指出来有哪些在等待，哪些资源可用。

信号量仅仅是对池资源进行监控，但不保证线程的安全，因此，在使用时候，应该自己控制线程的安全访问池资源。


----------
阻塞队列
Java定义了阻塞队列的接口java.util.concurrent.BlockingQueue，
阻塞队列的概念是，一个指定长度的队列，如果队列满了，添加新元素的操作会被阻塞等待，直到有空位为止。
同样，当队列为空时候，请求队列元素的操作同样会阻塞等待，直到有可用元素为止。
有了这样的功能，就为多线程的排队等候的模型实现开辟了便捷通道，非常有用。


----------
条件变量是Java5线程中很重要的一个概念，顾名思义，条件变量就是表示条件的一种变量。
但是必须说明，这里的条件是没有实际含义的，仅仅是个标记而已，并且条件的含义往往通过代码来赋予其含义。

这里的条件和普通意义上的条件表达式有着天壤之别。

条件变量都实现了java.util.concurrent.locks.Condition接口，
条件变量的实例化是通过一个Lock对象上调用newCondition()方法来获取的，这样，条件就和一个锁对象绑定起来了。
因此，Java中的条件变量只能和锁配合使用，来控制并发程序访问竞争资源的安全。

条件变量的出现是为了更精细控制线程等待与唤醒，在Java5之前，
线程的等待与唤醒依靠的是Object对象的wait()和notify()/notifyAll()方法，这样的处理不够精细。

而在Java5中，一个锁可以有多个条件，每个条件上可以有多个线程等待，通过调用await()方法，可以让线程在该条件下等待。
当调用signalAll()方法，又可以唤醒该条件下的等待的线程。有关Condition接口的API可以具体参考JavaAPI文档。

条件变量比较抽象，原因是他不是自然语言中的条件概念，而是程序控制的一种手段。

----------
所谓的原子量即操作变量的操作是“原子的”，该操作不可再分，因此是线程安全的。
为何要使用原子变量呢，原因是多个线程对单个变量操作也会引起一些问题。
在Java5之前，可以通过volatile、synchronized关键字来解决并发访问的安全问题，但这样太麻烦。
Java5之后，专门提供了用来进行单变量多线程并发安全访问的工具包java.util.concurrent.atomic，其中的类也很简单。

这里要注意的一点是，原子量虽然可以保证单个变量在某一个操作过程的安全，但无法保证你整个代码块，或者整个程序的安全性。
因此，通常还应该使用锁等同步机制来控制整个程序的安全性。
有关原子量的用法很简单，关键是对原子量的认识，原子仅仅是保证变量操作的原子性，但整个程序还需要考虑线程安全的。


----------
障碍器类，为了适应一种新的设计需求，
比如一个大型的任务，常常需要分配好多子任务去执行，只有当所有子任务都执行完成时候，才能执行主任务，

障碍器是多线程并发控制的一种手段


