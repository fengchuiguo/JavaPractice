并发协作-生产者消费者模型

实际上，准确说应该是“生产者-消费者-仓储”模型，离开了仓储，生产者消费者模型就显得没有说服力了。
对于此模型，应该明确一下几点：
1、生产者仅仅在仓储未满时候生产，仓满则停止生产。
2、消费者仅仅在仓储有产品时候才能消费，仓空则等待。
3、当消费者发现仓储没产品可消费时候会通知生产者生产。
4、生产者在生产出可消费产品时候，应该通知等待的消费者去消费。


生产者消费者模式的好处
它的确是一种实用的设计模式，常用于编写多线程或并发代码。下面是它的一些优点：
1,它简化的开发，你可以独立地或并发的编写消费者和生产者，它仅仅只需知道共享对象是谁
2,生产者不需要知道谁是消费者或者有多少消费者，对消费者来说也是一样
3,生产者和消费者可以以不同的速度执行
4,分离的消费者和生产者在功能上能写出更简洁、可读、易维护的代码


生产者消费者问题是研究多线程程序时绕不开的经典问题之一，
它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。
解决生产者/消费者问题的方法可分为两类：
（1）采用某种机制保护生产者和消费者之间的同步；
（2）在生产者和消费者之间建立一个管道。第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。
第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。因此本文只介绍同步机制实现的生产者/消费者问题。
同步问题核心在于：如何保证同一资源被多个线程并发访问时的完整性。
常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。
Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。
在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。
（1）wait() / notify()方法
（2）await() / signal()方法
（3）BlockingQueue阻塞队列方法
（4）PipedInputStream / PipedOutputStream
有兴趣的读者可以自己去网上找答案。




